

/**********************************************************************************************
 					Alexander Polynomials of 2-Generator, 1-Relator Groups
 					
 	Given the relator of a 2-Generator, 1-Relator group G, whose Abelianization is infinite
 	cyclic, this program computes the Alexander polynomial of G.
**********************************************************************************************/	

#include "Heegaard.h"
#include "Heegaard_Dec.h"	

/***************************** External Variables ******************************************/

unsigned char	*R = NULL,
 				*ptr1 = NULL,
				*ptr2 = NULL,
				*StrA = NULL,
				*StrB = NULL,
				*Stra = NULL,
				*Strb = NULL;

int				NumA,
				NumB,
				Numa, 
				Numb,
				RP, 
				RQ;
	
unsigned int	AP, 
				AQ;

/********************************* Function Prototypes **************************************
L  44 AlexanderPolynomial(void);
L 207 AlexanderPolynomial_GCD(unsigned int AP, unsigned int AQ);
L 279 ComputePrimitives(unsigned int p, unsigned int q, unsigned int r, unsigned int s);
L 441 ComputeAlexanderPolynomial(void);
L 741 CheckPolySymmetry(int *PolyCoeffs, unsigned int SizeCoeffArray);
L 767 FiberedCheck(void);
L 852 AlexanderPolynomial_Freely_Reduce(char* TransR, unsigned int LengthT);
L 897 CountMaxMins(char* TransR);
********************************************************************************************/	

int AlexanderPolynomial(unsigned char* u)
{
	char			x;

	unsigned char   *s,
					*t;
	
	unsigned int    m;
	
	if(Batch == 1 && H_Results != NULL) fprintf(H_Results,"\n\n%s",PresName);

	if(Batch == FALSE) printf("\n");
	R = u;    
	s = R;
	NumA = NumB = Numa = Numb = 0;
	while( (x = *s++) )
		{
		switch(x)
			{
			case 'A':
				NumA ++;
				break;
			case 'a':
				Numa ++;
				break;
			case 'B':
				NumB ++;
				break;
			case 'b':
				Numb ++;
				break;
			default:
				printf("\nThe relator R must contain only the characters 'A', 'B', 'a' and 'b'!");
				return(0);
			}
		}
	
	if(NumA >= Numa)
		AP = NumA - Numa;
	else
		AP = Numa - NumA;
	if(NumB >= Numb)
		AQ = NumB - Numb;
	else
		AQ = Numb - NumB;		
	
	if(AP == 0 && AQ == 0)
		{
		printf("\nThe input relator has trivial abelianization.");
		if(Batch == 1 && H_Results != NULL) fprintf(H_Results,"\nThis relator has trivial abelianization.");
		return(0);
		}
	if(1 != AlexanderPolynomial_GCD(AP,AQ))
		{
		printf("\nThe input relator is not a homology generator.");
		if(Batch == 1 && H_Results != NULL) fprintf(H_Results,"\nThis relator is not a homology generator.");
		return(0);
		}
		
/********************************************************************************************
						We have: AP*RP - AQ*RQ = 1
*********************************************************************************************/

	ComputePrimitives(RP,AQ,RQ,AP);
	
	if(RP + AQ >= RQ + AP)
		{
		m = RP + AQ;
		StrA = (unsigned char *) NewPtr(sizeof(char)*(m + 1));
		if(StrA == NULL) Mem_Error();
		StrB = (unsigned char *) NewPtr(sizeof(char)*(m + 1));
		if(StrB == NULL) Mem_Error();
		Stra = (unsigned char *) NewPtr(sizeof(char)*(m + 1));
		if(Stra == NULL) Mem_Error();
		Strb = (unsigned char *) NewPtr(sizeof(char)*(m + 1));
		if(Strb == NULL) Mem_Error();
		}
	else
		{
		m = RQ + AP;
		StrA = (unsigned char *) NewPtr(sizeof(char)*(m + 1));
		if(StrA == NULL) Mem_Error();
		StrB = (unsigned char *) NewPtr(sizeof(char)*(m + 1));
		if(StrB == NULL) Mem_Error();
		Stra = (unsigned char *) NewPtr(sizeof(char)*(m + 1));
		if(Stra == NULL) Mem_Error();
		Strb = (unsigned char *) NewPtr(sizeof(char)*(m + 1));
		if(Strb == NULL) Mem_Error();
		}	
		
	if(StrA == NULL || StrB == NULL || Stra == NULL || Strb == NULL) 
		{
		printf("\nMemory Error. Sorry!");
		return(1);
		}		

/*********************************************************************************************
		Assign 'A', 'B', 'a' and 'b' to their images in the free group generated by {X,Y}.
*********************************************************************************************/

if(RP + AQ >= RQ + AP)
	{
	s = ptr1;
	t = StrA;
	while( (*t++ = *s++) ) ;
	s = ptr1;
	t = Stra;
	while( (*t++ = *s++) ) ;
	s = ptr2;
	t = StrB;
	while( (*t++ = *s++) ) ;
	s = ptr2;
	t = Strb;
	while( (*t++ = *s++) ) ;
	}
if(RP + AQ < RQ + AP)
	{
	s = ptr2;
	t = StrA;
	while( (*t++ = *s++) ) ;
	s = ptr2;
	t = Stra;
	while( (*t++ = *s++) ) ;
	s = ptr1;
	t = StrB;
	while( (*t++ = *s++) ) ;
	s = ptr1;
	t = Strb;
	while( (*t++ = *s++) ) ;
	}

	if((NumA - Numa)*(NumB - Numb) >= 0)
		{
		Inverse(Stra);
		Inverse(StrB);
		}
	else
		{
		Inverse(Stra);
		Inverse(Strb);
		}	
	
	if(Micro_Print)
		{
		printf("\nA --> %s,",StrA);
		printf(" B --> %s," ,StrB);
		printf(" a --> %s," ,Stra);
		printf(" b --> %s," ,Strb);
		printf(" and Y^kXy^k --> t^k.\n");
		}
		
	ComputeAlexanderPolynomial();
	
	if(StrA) DisposePtr((unsigned char *) StrA);
	if(StrB) DisposePtr((unsigned char *) StrB);
	if(Stra) DisposePtr((unsigned char *) Stra);
	if(Strb) DisposePtr((unsigned char *) Strb);
	if(ptr1) DisposePtr((unsigned char *) ptr1);
	if(ptr2) DisposePtr((unsigned char *) ptr2);

	return(0);
}

unsigned int AlexanderPolynomial_GCD(unsigned int AP, unsigned int AQ)
{
	/******************************************************************************************
		Given a pair of nonnegative integers AP and AQ, this routine computes the GCD
		of AP and AQ and returns AlexanderPolynomial_GCD(AP,AQ) as an unsigned integer. 
		The routine simultaneously computes a pair of integers RP and RQ such that 
			the relation AP*RP - AQ*RQ =  AlexanderPolynomial_GCD(AP,AQ) holds.
	******************************************************************************************/	
	
	register int 	d,
					t,
					u2,
					v1,
					v2;
					
	int 			u1;
		
	u1 = 0;
	u2 = AP;
	v1 = 1;
	v2 = AQ;
	while(v2)
		{
		d = u2/v2;
		t = u1 - v1*d;
		u1 = v1;
		v1 = t;
		t = u2 - v2*d;
		u2 = v2;
		v2 = t;
		}
	if(AP)
		{
		t = u2 - AQ*u1;
		if(t < 0)
			{
			t = - t;
			RP = t/AP;
			RP = -RP;
			}
		else	
			RP = t/AP;
		}
	else
		RP = 0;		
	RQ = -u1;
	
	if(RP == 0 && RQ < 0)
		RQ = -RQ;
	if(RQ == 0 && RP < 0)
		RP = -RP;
	if(AP == 1 && AQ == 1)
		{
		RP = 1;
		RQ = 0;
		}	
	if(AP > 0 && AQ > 0)
		{
		while(RP < 0 && RQ < 0)
			{
			RP += AQ;
			RQ += AP;
			}
		while(RP > AQ && RQ > AP)
			{
			RP -= AQ;
			RQ -= AP;
			}	
		}		
	return(u2);
}

void ComputePrimitives(unsigned int RP, unsigned int AQ, unsigned int RQ, unsigned int AP)
{
	/******************************************************************************************
		Given a pair of relatively prime unsigned integers AP and AQ, this routine computes a
		pair of generators {g1,g2} of the free group of rank 2 generated by {X,Y} such that 
		g1 abelianizes to (RP,AQ) and g2 abelianizes to (RQ,AP).
	******************************************************************************************/
	
	unsigned char	*s;
	unsigned int 	m,
					n;
					
	if(AP == 1 && AQ == 0)
		{
		ptr1 = (unsigned char *) NewPtr(sizeof(char)*2);
		if(ptr1 == NULL) Mem_Error();
		ptr2 = (unsigned char *) NewPtr(sizeof(char)*2);
		if(ptr2 == NULL) Mem_Error();
		s = ptr1;
		*s++ = 'X';
		*s = EOS;
		s = ptr2;
		*s++ = 'Y';
		*s = EOS;
		return;		
		}
	if(AP == 0 && AQ == 1)
		{
		ptr1 = (unsigned char *) NewPtr(sizeof(char)*2);
		if(ptr1 == NULL) Mem_Error();
		ptr2 = (unsigned char *) NewPtr(sizeof(char)*2);
		if(ptr2 == NULL) Mem_Error();
		s = ptr1;
		*s++ = 'Y';
		*s = EOS;
		s = ptr2;
		*s++ = 'X';
		*s = EOS;
		return;		
		}
	if(AP == 1 && AQ == 1)
		{
		ptr1 = (unsigned char *) NewPtr(sizeof(char)*3);
		if(ptr1 == NULL) Mem_Error();
		ptr2 = (unsigned char *) NewPtr(sizeof(char)*2);
		if(ptr2 == NULL) Mem_Error();
		s = ptr1;
		*s++ = 'X';
		*s++ = 'Y';
		*s = EOS;
		s = ptr2;
		*s++ = 'Y';
		*s = EOS;
		return;				
		}						
	
	if(RP + AQ >= RQ + AP)
		{
		m = RP + AQ;
		ptr1 = (unsigned char *) NewPtr(sizeof(char)*(m + 1));
		if(ptr1 == NULL) Mem_Error();
		ptr2 = (unsigned char *) NewPtr(sizeof(char)*(m + 1));
		if(ptr2 == NULL) Mem_Error();
		s = ptr1;
		n = 1;
		do
			{
			if(n <= RP)
				*s++ = 'X';
			else
				*s++ = 'Y';
			n += AQ;
			if(n > m) n -= m;		
			}
		while(n != 1);	
		*s = EOS;
		
		s = ptr2;
		n = 1;
		do
			{
			if(n <= RP)
				*s++ = 'X';
			else
				*s++ = 'Y';
			n += AQ;
			if(n > m) n -= m;		
			}
		while(n != 2);	
		*s = EOS;
					
		if((s-ptr2) != RQ + AP)
			{
			s = ptr2;
			n = 2;
			do
				{
				if(n <= RP)
					*s++ = 'X';
				else
					*s++ = 'Y';
				n += AQ;
				if(n > m) n -= m;		
				}
			while(n != 1);	
			*s = EOS;
			}
		}
	else
		{
		m = RQ + AP;
		ptr1 = (unsigned char *) NewPtr(sizeof(char)*(m + 1));
		if(ptr1 == NULL) Mem_Error();
		ptr2 = (unsigned char *) NewPtr(sizeof(char)*(m + 1));
		if(ptr2 == NULL) Mem_Error();
		s = ptr1;
		n = 1;
		do
			{
			if(n <= RQ)
				*s++ = 'X';
			else
				*s++ = 'Y';
			n += AP;
			if(n > m) n -= m;		
			}
		while(n != 1);	
		*s = EOS;
		
		s = ptr2;
		n = 1;
		do
			{
			if(n <= RQ)
				*s++ = 'X';
			else
				*s++ = 'Y';
			n += AP;
			if(n > m) n -= m;						
			}
		while(n != 2);	
		*s = EOS;
		
		if((s-ptr2) != RP + AQ)
			{
			s = ptr2;
			n = 2;
			do
				{
				if(n <= RQ)
					*s++ = 'X';
				else
					*s++ = 'Y';
				n += AP;
				if(n > m) n -= m;						
				}
			while(n != 1);	
			*s = EOS;
			}
		}
}

void ComputeAlexanderPolynomial(void)
{
	unsigned char	*s,
					*t,
					u,
					v;
			
	int				MaxSumY,
					MinSumY,
					Offset,
					*PolyCoeffs = NULL,
					SumY;
			
	unsigned int	n,
					m,
					SizeCoeffArray;		

/*********************************************************************************************			
	Read through the relator R and determine the minimum and maximum exponent sums of Y that
	occur in R when R is rewritten in terms of {X,Y}.		
**********************************************************************************************/			

	MaxSumY = MinSumY = SumY = 0;
	s = R;
	while( (u = *s++) ) switch(u)
		{
		case 'A':
			t = StrA;
			while( (v = *t++) ) switch(v)
				{
				case 'X':
					break;
				case 'Y':
					SumY ++;
					break;
				case 'x':
					break;
				case 'y':
					SumY --;
					break;	
				}
			if(SumY > MaxSumY) MaxSumY = SumY;
			if(SumY < MinSumY) MinSumY = SumY;
			break;			
		case 'B':
			t = StrB;
			while( (v = *t++) ) switch(v)
				{
				case 'X':
					break;
				case 'Y':
					SumY ++;
					break;
				case 'x':
					break;
				case 'y':
					SumY --;
					break;	
				}
			if(SumY > MaxSumY) MaxSumY = SumY;
			if(SumY < MinSumY) MinSumY = SumY;
			break;			
		case 'a':
			t = Stra;
			while( (v = *t++) ) switch(v)
				{
				case 'X':
					break;
				case 'Y':
					SumY ++;
					break;
				case 'x':
					break;
				case 'y':
					SumY --;
					break;	
				}
			if(SumY > MaxSumY) MaxSumY = SumY;
			if(SumY < MinSumY) MinSumY = SumY;
			break;			
		case 'b':
			t = Strb;
			while( (v = *t++) ) switch(v)
				{
				case 'X':
					break;
				case 'Y':
					SumY ++;
					break;
				case 'x':
					break;
				case 'y':
					SumY --;
					break;	
				}
			if(SumY > MaxSumY) MaxSumY = SumY;
			if(SumY < MinSumY) MinSumY = SumY;
			break;			
		}
		
	/*****************************************************************************************
		Get an array of size MaxSumy - MinSumy + 1 to hold the coefficients of the 
		Alexander polynomial. Iniitalize the array by setting all entries to 0.
	*****************************************************************************************/
	
	SizeCoeffArray = MaxSumY - MinSumY + 1;
	PolyCoeffs = (int *) NewPtr(sizeof(int)*SizeCoeffArray);
	if(PolyCoeffs == NULL) Mem_Error();
	
	for(n = 0; n < SizeCoeffArray; n++) PolyCoeffs[n] = 0; 
	
	/*****************************************************************************************
		Read through R and accumulate the coefficients of the Alexander polynomial in the
		array PolyCoeffs. Also count the number of times the minimum value of SumY is 
		attained and the number of times the maximum value of SumY is attained. If neither of 
		these values is attained more than once, the commutator subgroup of G is finitely
		generated.
	*****************************************************************************************/
	
	SumY = 0;
	s = R;
	while( (u = *s++) ) switch(u)
		{
		case 'A':
			t = StrA;
			while( (v = *t++) ) switch(v)
				{
				case 'X':
					PolyCoeffs[SumY - MinSumY] ++;
					break;
				case 'Y':
					SumY ++;
					break;
				case 'x':
					PolyCoeffs[SumY - MinSumY] --;
					break;
				case 'y':
					SumY --;
					break;	
				}
			break;			
		case 'B':
			t = StrB;
			while( (v = *t++) ) switch(v)
				{
				case 'X':
					PolyCoeffs[SumY - MinSumY] ++;
					break;
				case 'Y':
					SumY ++;
					break;
				case 'x':
					PolyCoeffs[SumY - MinSumY] --;
					break;
				case 'y':
					SumY --;
					break;	
				}
			break;			
		case 'a':
			t = Stra;
			while( (v = *t++) ) switch(v)
				{
				case 'X':
					PolyCoeffs[SumY - MinSumY] ++;
					break;
				case 'Y':
					SumY ++;
					break;
				case 'x':
					PolyCoeffs[SumY - MinSumY] --;
					break;
				case 'y':
					SumY --;
					break;	
				}
			break;			
		case 'b':
			t = Strb;
			while( (v = *t++) ) switch(v)
				{
				case 'X':
					PolyCoeffs[SumY - MinSumY] ++;
					break;
				case 'Y':
					SumY ++;
					break;
				case 'x':
					PolyCoeffs[SumY - MinSumY] --;
					break;
				case 'y':
					SumY --;
					break;	
				}
			break;			
		}
	
	/*****************************************************************************************
		Look for the location of the first nonzero coefficient in the array PolyCoeffs[ ].
	*****************************************************************************************/
	
	for(n = 0; PolyCoeffs[n] == 0 && n < SizeCoeffArray; n++) ;
	if(n >= SizeCoeffArray)
		{
		printf("\nThe Alexander Polynomial is the zero polynomial.\n");
		if(Batch == 1 && H_Results != NULL) fprintf(H_Results,"\nThe Alexander Polynomial is the zero polynomial.\n");
		if(PolyCoeffs) DisposePtr((int *) PolyCoeffs);
		return;
		}
	
	Offset = -n;
	
	/******************************************************************************************
			Normalize the coefficients so that the constant term is positive.
	******************************************************************************************/
	
	if(PolyCoeffs[n] < 0) for(m = n; m < SizeCoeffArray; m++)
		{
		if(PolyCoeffs[m]) PolyCoeffs[m] = - PolyCoeffs[m];
		}	
	
	printf("\nThe Alexander polynomial is: %d",PolyCoeffs[n]);
	if(Batch == 1 && H_Results != NULL) fprintf(H_Results,"\nThe Alexander polynomial is: %d",PolyCoeffs[n]);
	n++;
	for( ;n < SizeCoeffArray; n++)
		{
		if(PolyCoeffs[n] > 0)
			{
			if(PolyCoeffs[n] == 1)
				{
				if(n + Offset == 1)
					{
					printf("+t");
					if(Batch == 1 && H_Results != NULL) fprintf(H_Results,"+t");
					}
				else
					{	
					printf("+t^%d",n + Offset);
					if(Batch == 1 && H_Results != NULL) fprintf(H_Results,"+t^%d",n + Offset);
					}
				}
			else
				{	
				printf("+%d",PolyCoeffs[n]);
				if(Batch == 1 && H_Results != NULL) fprintf(H_Results,"+%d",PolyCoeffs[n]);
				if(n + Offset == 1)
					{
					printf("t");
					if(Batch == 1 && H_Results != NULL) fprintf(H_Results,"t");
					}
				else
					{	
					printf("t^%d",n + Offset);
					if(Batch == 1 && H_Results != NULL) fprintf(H_Results,"t^%d",n + Offset);
					}
				}
			}
		if(PolyCoeffs[n] < 0)
			{
			if(PolyCoeffs[n] == -1)
				{
				if(n + Offset == 1)
					{
					printf("-t");
					if(Batch == 1 && H_Results != NULL) fprintf(H_Results,"-t");
					}
				else
					{
					printf("-t^%d",n + Offset);
					if(Batch == 1 && H_Results != NULL) fprintf(H_Results,"-t^%d",n + Offset);
					}
				}
			else
				{
				printf("%d",PolyCoeffs[n]);
				if(Batch == 1 && H_Results != NULL) fprintf(H_Results,"%d",PolyCoeffs[n]);
				if(n + Offset == 1)
					{
					printf("t");
					if(Batch == 1 && H_Results != NULL) fprintf(H_Results,"t");
					}
				else
					{
					printf("t^%d",n + Offset);
					if(Batch == 1 && H_Results != NULL) fprintf(H_Results,"t^%d",n + Offset);
					}
				}
			}
		}
	
	CheckPolySymmetry(PolyCoeffs, SizeCoeffArray);
	
	if(PolyCoeffs[-Offset] == 1)
		FiberedCheck();
	
	if(PolyCoeffs) DisposePtr((int *) PolyCoeffs);
		
	return;	
}

void CheckPolySymmetry(int* PolyCoeffs, unsigned int SizeCoeffArray)
{
	int		*p,
			*q;

	/*****************************************************************************************
		Look for the location of the first and last nonzero coefficients in PolyCoeffs[ ].
	*****************************************************************************************/
	
	for(p = PolyCoeffs; *p == 0; p++) ;
	for(q = PolyCoeffs + SizeCoeffArray - 1; *q == 0; q--) ;
	
	/*****************************************************************************************
			Check whether the polynomial coefficients are symmetric.
	*****************************************************************************************/
	
	for( ; p < q; p++,q--) if(*p != *q)
		{
		printf(" 	\n\nThis polynomial is not symmetric.");
		if(Batch == 1 && H_Results != NULL) fprintf(H_Results," 	\n\nThis polynomial is not symmetric.");
		break;
		}		


}

int FiberedCheck(void)
{
	unsigned char	*p,
					*q,
					*r,
					*TransR = NULL,
					x;
			
	unsigned int	lengthR,
					lengthT,
					MaxlengthStr;
	
	/***************************************************************************************
		Compute the length of the input relator R and get some storage to hold the string 
		obtained when StrA, StrB, Stra and Strb are substituted for A, B, a and b in R.
		
	***************************************************************************************/
	
	for(lengthR = 0, p = R; *p ; p++) lengthR ++;
	
	if(RP + AQ >= RQ + AP)
		MaxlengthStr = RP + AQ;
	else
		MaxlengthStr = RQ + AP;
		
	lengthT = lengthR*MaxlengthStr;
	lengthT +=2;
	
	TransR = (unsigned char *) NewPtr(sizeof(char)*lengthT);
	if(TransR == NULL) Mem_Error();
	
	q = TransR;
	*q++ = '@';
	r = R;
	while( (x = *r++) ) switch(x)
		{
		case 'A':
			p = StrA;
			while( (*q++ = *p++) ) ;
			q--;
			break;
		case 'B':
			p = StrB;
			while( (*q++ = *p++) ) ;
			q--;
			break;
		case 'a':
			p = Stra;
			while( (*q++ = *p++) ) ;
			q--;
			break;
		case 'b':
			p = Strb;
			while( (*q++ = *p++) ) ;
			q--;
			break;
		}
	*q = EOS;

	if(AlexanderPolynomial_Freely_Reduce(TransR, lengthT))
		{
		if(TransR) DisposePtr((char *) TransR);
		return(1);		
		}
	
	if(CountMaxMins((char *) TransR) == 1)
		{
		printf("\n\nThe commutator subgroup of the group G = < A,B | R 1 > is finitely generated.");
		if(Batch == 1 && H_Results != NULL) 
			fprintf(H_Results,"\n\nThe commutator subgroup of the group G = < A,B | R 1 > is finitely generated.");
		if(TransR) DisposePtr((char *) TransR);
		return(1);
		}
	else
		{
		printf("\n\nThe commutator subgroup of the group G = < A,B | R 1 > is infinitely generated.");
		if(Batch == 1 && H_Results != NULL) 
			fprintf(H_Results,"\n\nThe commutator subgroup of the group G = < A,B | R 1 > is infinitely generated.");
		if(TransR) DisposePtr((char *) TransR);
		return(1);
		}		
	if(TransR) DisposePtr((char *) TransR);
	return(0);	
}

int AlexanderPolynomial_Freely_Reduce(unsigned char* TransR, unsigned int lengthT)
{
	/******************************************************************************************
						This routine freely reduces the relator TransR.
	******************************************************************************************/
	
	register unsigned char	*p,
							*q,
							*TempR = NULL;
	
	TempR = (unsigned char*) NewPtr(sizeof(char)*lengthT);
	if(TempR == NULL) Mem_Error();
	
	q = (unsigned char*)TransR;
	if(*q == '@') q++;
	p = TempR;
	*p = '@';
	while(*q)
		{
		if((*p - *q) == 32 || (*p - *q) == -32)
			p--;
		else 
			{
			p++;
			*p = *q;
			}	
		q++;			
		}
	q = TempR;
	q++;
	if(p > q) while((*p - *q) == 32 || (*p - *q) == -32)
		{
		p--;
		q++;
		}
	p++;
	*p = EOS;
	
	p = (unsigned char *)TransR;
	while( (*p++ = *q++) ) ;
	
	if(TempR) DisposePtr(TempR);
	return(0);
}

int CountMaxMins(char* TransR)
{
	char	*p,
			s;		
	
	int 	MaxSumY,
			MinSumY,
			NumMax,
			NumMin,
			SumY;
			
	NumMax = NumMin = SumY = 0;
	MaxSumY = -20000000;
	MinSumY =  20000000;
	
				 
	p = TransR;
	
	while( (s = *p++) ) switch(s)
		{
		case 'X':
		case 'x':
			if(SumY == MinSumY)
				NumMin ++;
			if(SumY < MinSumY)
				{
				MinSumY = SumY;
				NumMin = 1;
				}
			if(SumY == MaxSumY)
				NumMax ++;
			if(SumY > MaxSumY)
				{
				MaxSumY = SumY;
				NumMax = 1;
				}
			break;
		case 'Y':
			SumY ++;
			break;
		case 'y':
			SumY --;
			break;
		}				 
	
/*	printf("\n%s,StrA = %s, StrB = %s, Stra = %s, Strb = %s",R,StrA,StrB,Stra,Strb);
	printf("\n%s, Min = %d, Max = %d, #Min = %d, #Max = %d.",TransR,MinSumY,MaxSumY,NumMin,NumMax); */
	
	if(NumMin == 1 && NumMax == 1)
		return(1);
	return(0);
}
